# Express Azure Functions

This is simple project that shows how this library can be easily integrated with, as a standalone utility.

As with other examples & tests, we're using PetStore specification as our baseline test - so all the examples below will contain references to Categories, Orders, Pets & Users.

# Setup

Install the package

```sh
npm install the-bodyguard
```

Add openapi file to the root of the repository & create a generation step in your `package.json` i.e.

```json
...
  "scripts": {
    "build:validation": "the-bodyguard --openapi petstore.yaml --output  .api",

```

Generate the validation functions

```sh
npm run build:validation
```

Now that we have generated our functions, we can use them in our request implementations:

### Simple validation

Simple validation is a straight `true`/`false` evaluation with no details being provided. It's very convenient if you have no need to generate responses with errors etc.

```ts
import { PetValidator } from './.api/dist';
// ...

// Simple validation
export const addPetHandler = async (
  request: HttpRequest,
  context: InvocationContext
): Promise<HttpResponseInit> => {
  const body = await request.json();
  if (!PetValidator(body)) {
    context.log('Invalid request received');
    return { jsonBody: { success: false }, status: 400 };
  }

  return { jsonBody: { success: true }, status: 200 };
};

// Register the endpoint
app.http('addPet', {
  methods: ['POST'],
  route: 'pet',
  handler: addPetHandler
});
```

### Validation with errors

If we want to provide a bit more details as to why we are rejecting our requests, we can use with \*ValidationWithResults validator instead, which always returns a tuple of validated instance, and errors. If validation false, the instance is `undefined`, and if it passes, the instance is passed back as a cast response.

```ts
// Validation with error results
export const createUserHandler = async (
  request: HttpRequest,
  context: InvocationContext
): Promise<HttpResponseInit> => {
  const body = await request.json();
  const [user, errors] = UserValidatorWithErrors(body);
  
  if (errors) {
    context.log('Invalid request received');
    return {
      jsonBody: { success: false, errors },
      status: 400
    };
  }

  return {
    jsonBody: { success: true, user },
    status: 200
  };
};

// Register the endpoint
app.http('createUser', {
  methods: ['POST'],
  route: 'user',
  handler: createUserHandler
});
```

### Validation as a middleware

Core point of this project is to save time & avoid repetition, we can take a similar approach and just wrap the validation function into a middleware & easily re-use it across our APIs, a very simple example of that could be
as follows:

```ts
// Validation as a wrapper function
const validated = <T>(
  validator: (body: unknown) => boolean,
  schema: Record<string, unknown>,
  handler: (
    request: HttpRequest,
    context: InvocationContext,
    validatedBody: T
  ) => FunctionResult<HttpResponseInit | HttpResponse>
) => {
  return async (
    request: HttpRequest,
    context: InvocationContext
  ): Promise<HttpResponseInit> => {
    // If validation fails - return error
    const body = await request.json();
    if (!validator(body)) {
      return {
        jsonBody: { error: 'Invalid response body', expectedSchema: schema },
        status: 400
      };
    }
    // If validation has passed, execute actual handler
    return await handler(request, context, body as T);
  };
};
```

With the definition above, we can use all of the validators generated by the library, without explicitly having to create a new middleware function for each. Then we can use this the above as follows

```ts
// Validation with error results
export const createCategoryHandler = validated<Category>(
  CategoryValidator,
  CategorySchema,
  async (
    request: HttpRequest,
    context: InvocationContext,
    category
  ): Promise<HttpResponseInit> => {
    // We know for sure that we have received a valid body
    return {
      jsonBody: { success: true, category },
      status: 200
    };
  }
);

// Register the handler
app.http('createCategory', {
  methods: ['POST'],
  route: 'category',
  handler: createCategoryHandler
});
```

There are many different ways that you could implement this library, but the core principle of it means that it should be easily transferrable to a different platform without any extra issues.

See [./index.ts](./index.ts) for a full detail & feel free to clone this project locally :)
