# Express Example project

This is simple project that shows how this library can be easily integrated with, as a standalone utility.

As with other examples & tests, we're using PetStore specification as our baseline test - so all the examples below will contain references to Categories, Orders, Pets & Users.

# Setup

Install the package

```sh
npm install the-bodyguard
```

Add openapi file to the root of the repository & create a generation step in your `package.json` i.e.

```json
...
  "scripts": {
    "build:validation": "the-bodyguard --openapi petstore.yaml --output .generated/validation",
...
```

Generate the validation functions

```sh
npm run build:validation
```

Now that we have generated our functions, we can use them in our request implementations:

### Simple validation

Simple validation is a straight `true`/`false` evaluation with no details being provided. It's very convenient if you have no need to generate responses with errors etc.

```ts
import { PetValidator } from './.generated/validation/dist';
...

app.post(`/pet`, (req: Request, res: Response) => {
  if (PetValidator(req.body)) {
    return res.status(200).send({ success: true });
  }
  return res.status(400).send({ success: false });
});
```

### Validation with errors

If we want to provide a bit more details as to why we are rejecting our requests, we can use with \*ValidationWithResults validator instead, which always returns a tuple of validated instance, and errors. If validation false, the instance is `undefined`, and if it passes, the instance is passed back as a cast response.

```ts
app.post(`/user`, (req: Request, res: Response) => {
  const [user, errors] = UserValidatorWithErrors(req.body);
  if (user) {
    return res.status(200).send({ success: true, user });
  }
  return res.status(400).send({ success: false, errors });
});
```

### Validation as a middleware

Core point of this project is to save time & avoid repetition, we can take a similar approach and just wrap the validation function into a middleware & easily re-use it across our APIs, a very simple example of that could be
as follows:

```ts
export const validationMiddleware = (
  validator: (body: unknown) => boolean,
  expectedSchema: Record<string, unknown>
) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!validator(req.body)) {
      return res
        .status(400)
        .send({ error: 'Invalid response body', expectedSchema });
    }
    next();
  };
};
```

With the definition above, we can use all of the validators generated by the library, without explicitly having to create a new middleware function for each. Then we can use this the above as follows

```ts
app.post(
  `/category`,
  validationMiddleware(CategoryValidator, CategorySchema),
  (req: Request<ParamsDictionary, Category>, res: Response) => {
    const category = req.body;
    return res.status(200).send({ success: true, category });
  }
);
```

There are many different ways that you could implement this library, but the core principle of it means that it should be easily transferrable to a different platform without any extra issues.

See [./index.ts](./index.ts) for a full detail & feel free to clone this project locally :)
